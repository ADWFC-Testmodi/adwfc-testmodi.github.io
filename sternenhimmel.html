<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sternenhimmel Test</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; background: black; height: 100%;
  }
  canvas {
    display: block;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="starCanvas"></canvas>
<script>
(() => {
  const canvas = document.getElementById('starCanvas');
  const ctx = canvas.getContext('2d');

  let w, h, centerY;
  function resize() {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
    centerY = h / 2;
  }
  resize();
  window.addEventListener('resize', resize);

  const wallLengthPx = 1600;
  const starCount = 80;

  const stars = [];
  for(let i = 0; i < starCount; i++) {
    stars.push({
      x: Math.random() * wallLengthPx,
      y: Math.random() * h,
      radius: 2
    });
  }

  const anchorX = 800;

  // Startkamera mittig, damit wir links und rechts Puffer haben
  let cameraX = wallLengthPx / 2 - w / 2;

  let velocity = 0;
  let isDragging = false;
  let lastDragX = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = 'white';

    stars.forEach(star => {
      let screenX = star.x - cameraX;
      if (screenX >= -50 && screenX <= w + 50) {
        ctx.beginPath();
        ctx.arc(screenX, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    const anchorScreenX = anchorX - cameraX;
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(anchorScreenX, h/2, 5, 0, Math.PI * 2);
    ctx.fill();
  }

  function clampCamera(x) {
    const min = -200;
    const max = wallLengthPx - w + 200;
    if (x < min) return min;
    if (x > max) return max;
    return x;
  }

  function animate() {
    if (!isDragging) {
      if (Math.abs(velocity) > 0.005) {
        cameraX = clampCamera(cameraX - velocity);
        velocity *= 0.96;
      } else {
        velocity = 0;
      }
    }
    draw();
    requestAnimationFrame(animate);
  }
  animate();

  function pointerDown(e) {
    isDragging = true;
    velocity = 0;
    lastDragX = e.clientX || e.touches[0].clientX;
  }
  function pointerMove(e) {
    if (!isDragging) return;
    const currentX = e.clientX || e.touches[0].clientX;
    let delta = currentX - lastDragX;
    lastDragX = currentX;
    cameraX = clampCamera(cameraX - delta);

    const maxVelocity = 30;
    if (delta > maxVelocity) delta = maxVelocity;
    else if (delta < -maxVelocity) delta = -maxVelocity;

    velocity = delta;
  }
  function pointerUp() {
    isDragging = false;
    velocity *= 0.8;
  }

  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('touchstart', pointerDown, {passive:false});
  canvas.addEventListener('mousemove', pointerMove);
  canvas.addEventListener('touchmove', pointerMove, {passive:false});
  canvas.addEventListener('mouseup', pointerUp);
  canvas.addEventListener('touchend', pointerUp);
  canvas.addEventListener('touchcancel', pointerUp);
})();
</script>
</body>
</html>
